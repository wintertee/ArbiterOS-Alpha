"""{{ domain }}-specific policy checkers for ArbiterOS governance.

This module provides policy checkers designed for the {{ domain }}
multi-agent framework, enforcing workflow constraints and safety requirements.

PolicyCheckers validate execution constraints BEFORE instruction execution.
If validation fails, the checker returns False and blocks the execution,
preventing unsafe or invalid operations from proceeding.

Generated by ArbiterOS Migration Tool.
"""

import logging
from dataclasses import dataclass, field
from typing import List, Set, Optional

from arbiteros_alpha.history import History
from arbiteros_alpha.instructions import (
{% for import in instruction_imports %}
    {{ import }},
{% endfor %}
)
from arbiteros_alpha.policy import PolicyChecker

logger = logging.getLogger(__name__)


class PolicyViolationError(Exception):
    """Raised when a policy check fails and blocks execution."""
    
    def __init__(self, policy_name: str, message: str, history_context: dict = None):
        self.policy_name = policy_name
        self.message = message
        self.history_context = history_context or {}
        super().__init__(f"[{policy_name}] {message}")

{% for checker in checkers %}

@dataclass
class {{ checker.class_name }}(PolicyChecker):
    """{{ checker.description }}

    This checker enforces safety constraints by validating execution state
    BEFORE allowing the instruction to proceed. If validation fails, the
    instruction is BLOCKED.

    Attributes:
        name: Human-readable name for this policy checker.
        strict_mode: If True, raises PolicyViolationError on failure. If False, logs warning and returns False.
{% for param_name, param_desc in checker.parameter_descriptions.items() %}
        {{ param_name }}: {{ param_desc }}
{% endfor %}

    Example:
        >>> checker = {{ checker.class_name }}(
        ...     name="{{ checker.class_name | lower }}",
        ...     strict_mode=True,
{% for param_name, param_value in checker.parameters.items() %}
{% if param_value is string %}
        ...     {{ param_name }}="{{ param_value }}"
{% else %}
        ...     {{ param_name }}={{ param_value }}
{% endif %}
{% endfor %}
        ... )
        >>> arbiter_os.add_policy_checker(checker)
    """

    name: str
    strict_mode: bool = True  # Default to strict enforcement
{% for param_name, param_value in checker.parameters.items() %}
{% if param_value is mapping %}
    {{ param_name }}: dict = field(default_factory=lambda: {{ param_value }})
{% elif param_value is iterable and param_value is not string %}
    {{ param_name }}: {{ checker.parameter_types.get(param_name, 'list') }} = field(default_factory=lambda: {{ param_value | list }})
{% elif param_value is string %}
    {{ param_name }}: {{ checker.parameter_types.get(param_name, 'str') }} = "{{ param_value }}"
{% elif param_value is number %}
    {{ param_name }}: {{ checker.parameter_types.get(param_name, 'float') }} = {{ param_value }}
{% else %}
    {{ param_name }}: {{ checker.parameter_types.get(param_name, 'Any') }} = {{ param_value }}
{% endif %}
{% endfor %}

    def check_before(self, history: History) -> bool:
        """{{ checker.check_logic_description }}

        This method ENFORCES the policy constraint. If the constraint is violated:
        - In strict_mode: raises PolicyViolationError to halt execution
        - Otherwise: returns False to block the instruction

        Args:
            history: The execution history up to this point.

        Returns:
            True if validation passes and execution may proceed.
            False if validation fails and execution should be blocked.

        Raises:
            PolicyViolationError: In strict_mode when validation fails.
        """
        if not history.entries:
            logger.debug(f"[{self.name}] No history entries, allowing execution")
            return True

        # Count relevant instructions across all supersteps
{% for instr in checker.instructions_to_track %}
        {{ instr.value.lower() }}_count = 0
{% endfor %}
        
        # Track the last outputs for state validation
        last_output_state = None
        
        for superstep in history.entries:
            for item in superstep:
{% for instr in checker.instructions_to_track %}
                if item.instruction == {{ instr.full_ref }}:
                    {{ instr.value.lower() }}_count += 1
                    last_output_state = item.output_state
{% endfor %}

        # === VALIDATION LOGIC ===
        # Implement domain-specific validation based on instruction counts and state
        
{% if 'completion' in checker.class_name.lower() or 'require' in checker.class_name.lower() %}
        # Completion/Requirement Check: Ensure minimum required executions
        total_count = sum([{% for instr in checker.instructions_to_track %}{{ instr.value.lower() }}_count{% if not loop.last %}, {% endif %}{% endfor %}])
        min_required = getattr(self, 'min_required', 1)
        
        if total_count < min_required:
            # Remove f-string variables from error message template as they may not exist in context
            base_error_msg = """{{ checker.error_message_template }}""".split('{')[0].rstrip('.')
            error_msg = (
                f"{base_error_msg}."
                f" Required: {min_required}, Found: {total_count}"
            )
            logger.warning(f"[{self.name}] {error_msg}")
            
            if self.strict_mode:
                raise PolicyViolationError(
                    self.name, 
                    error_msg,
                    {"required": min_required, "found": total_count}
                )
            return False
{% elif 'compliance' in checker.class_name.lower() or 'constraint' in checker.class_name.lower() %}
        # Compliance Check: Validate state meets requirements before critical actions
        if last_output_state:
            # Check for required approval or validation flags
            is_validated = last_output_state.get('validated', False)
            is_approved = last_output_state.get('approved', False)
            risk_level = last_output_state.get('risk_level', 0.0)
            
            # Block high-risk operations without validation
            max_risk_threshold = getattr(self, 'max_risk_threshold', 0.8)
            requires_approval = getattr(self, 'requires_approval', False)
            
            if isinstance(risk_level, (int, float)) and risk_level > max_risk_threshold:
                error_msg = (
                    f"{{ checker.error_message_template }}"
                    f" Risk level {risk_level} exceeds threshold {max_risk_threshold}"
                )
                logger.warning(f"[{self.name}] {error_msg}")
                
                if self.strict_mode:
                    raise PolicyViolationError(
                        self.name,
                        error_msg,
                        {"risk_level": risk_level, "threshold": max_risk_threshold}
                    )
                return False
            
            if requires_approval and not is_approved:
                error_msg = f"{{ checker.error_message_template }} Operation requires approval."
                logger.warning(f"[{self.name}] {error_msg}")
                
                if self.strict_mode:
                    raise PolicyViolationError(self.name, error_msg, {"approved": is_approved})
                return False
{% elif 'availability' in checker.class_name.lower() or 'data' in checker.class_name.lower() %}
        # Data Availability Check: Ensure required data is present
        if last_output_state:
            required_fields = getattr(self, 'required_fields', [])
            missing_fields = [f for f in required_fields if f not in last_output_state or last_output_state[f] is None]
            
            if missing_fields:
                error_msg = (
                    f"{{ checker.error_message_template }}"
                    f" Missing required data fields: {missing_fields}"
                )
                logger.warning(f"[{self.name}] {error_msg}")
                
                if self.strict_mode:
                    raise PolicyViolationError(
                        self.name,
                        error_msg,
                        {"missing_fields": missing_fields}
                    )
                return False
{% else %}
        # Generic validation: Log and pass (customize for specific domains)
        # This is a fallback - domain-specific logic should be added above
{% endif %}

        # Log successful validation
        logger.info(
            f"[{self.name}] {{ checker.class_name }} validation PASSED: "
{% for instr in checker.instructions_to_track %}
            f"{{ instr.value }}={{ '{'}}{{ instr.value.lower() }}_count{{ '}' }}{% if not loop.last %}, {% endif %}"
{% endfor %}
        )

        return True

{% endfor %}

# =============================================================================
# Verification Node Utilities
# =============================================================================

def create_verification_checker(
    name: str,
    target_instruction: "InstructionType",
    verification_instruction: "InstructionType",
    min_verifications: int = 1,
    strict_mode: bool = True,
) -> PolicyChecker:
    """Factory function to create a verification requirement checker.
    
    This creates a checker that ensures a verification step has been executed
    before allowing the target instruction to proceed.
    
    Args:
        name: Name for the checker.
        target_instruction: The instruction type that requires verification.
        verification_instruction: The instruction type that provides verification.
        min_verifications: Minimum number of verification steps required.
        strict_mode: If True, raises error on failure.
        
    Returns:
        A configured PolicyChecker instance.
        
    Example:
        >>> # Require VERIFY before TOOL_CALL (trading execution)
        >>> checker = create_verification_checker(
        ...     name="require_verify_before_trade",
        ...     target_instruction=ExecutionCore.TOOL_CALL,
        ...     verification_instruction=NormativeCore.VERIFY,
        ...     min_verifications=1
        ... )
    """
    from arbiteros_alpha.instructions import NormativeCore
    
    @dataclass
    class DynamicVerificationChecker(PolicyChecker):
        name: str
        target_instruction: "InstructionType"
        verification_instruction: "InstructionType"
        min_verifications: int = 1
        strict_mode: bool = True
        
        def check_before(self, history: History) -> bool:
            if not history.entries:
                return True
                
            verification_count = 0
            target_pending = False
            
            for superstep in history.entries:
                for item in superstep:
                    if item.instruction == self.verification_instruction:
                        verification_count += 1
                    if item.instruction == self.target_instruction:
                        # Check if verification happened before this target
                        if verification_count < self.min_verifications:
                            error_msg = (
                                f"Instruction {self.target_instruction.name} requires "
                                f"at least {self.min_verifications} {self.verification_instruction.name} "
                                f"step(s). Found: {verification_count}"
                            )
                            logger.warning(f"[{self.name}] {error_msg}")
                            
                            if self.strict_mode:
                                raise PolicyViolationError(self.name, error_msg)
                            return False
            
            return True
    
    return DynamicVerificationChecker(
        name=name,
        target_instruction=target_instruction,
        verification_instruction=verification_instruction,
        min_verifications=min_verifications,
        strict_mode=strict_mode
    )
