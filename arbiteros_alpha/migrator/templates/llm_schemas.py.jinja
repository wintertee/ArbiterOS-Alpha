"""Pydantic schemas for standardized LLM I/O in {{ domain }}.

These schemas enforce the "strict schema + post-call validation" pattern described
in ArbiterOS ACF docs. They are designed to ensure consistent, validated JSON
outputs from LLM calls.

Usage:
    # Import schemas
    from llm_schemas import BullResearcherOutput, TraderDecisionOutput

    # Wire into LLM calls using with_structured_output
    structured_llm = llm.with_structured_output(BullResearcherOutput)
    result = structured_llm.invoke(prompt)
    # result is now a validated Pydantic object
    # Access via result.content (string) or result.field_name (typed)

Generated by ArbiterOS Migration Tool.
"""

from __future__ import annotations

from enum import Enum
from typing import List, Literal, Optional, Dict, Any

from pydantic import BaseModel, Field

{% for import in additional_imports %}
{{ import }}
{% endfor %}

try:
    from langchain_core.messages import AIMessage
    _HAS_LANGCHAIN = True
except ImportError:
    _HAS_LANGCHAIN = False


# =============================================================================
# Schema-Function Mapping
# =============================================================================
# Maps agent function names to their output schema classes.
# Used by governed agent wrappers to wire schemas into LLM calls.

SCHEMA_FUNCTION_MAP: Dict[str, str] = {
{% for schema in schemas %}
{% if schema.function_names %}
{% for func_name in schema.function_names %}
    "{{ func_name }}": "{{ schema.class_name }}",
{% endfor %}
{% endif %}
{% endfor %}
}


def get_schema_for_function(func_name: str) -> type[BaseModel] | None:
    """Get the output schema class for a given function name.

    Args:
        func_name: Name of the agent function.

    Returns:
        The Pydantic schema class, or None if no mapping exists.
    """
    schema_name = SCHEMA_FUNCTION_MAP.get(func_name)
    if schema_name:
        return globals().get(schema_name)
    return None


# =============================================================================
# Output Schemas
# =============================================================================

{% for schema in schemas %}
{% if schema.is_enum %}
class {{ schema.class_name }}(str, Enum):
    """{{ schema.description }}"""

{% for value in schema.enum_values %}
    {{ value }} = "{{ value }}"
{% endfor %}

{% else %}
class {{ schema.class_name }}({{ schema.base_class }}):
    """{{ schema.description }}

{% if schema.function_names %}
    Used by: {{ schema.function_names | join(', ') }}
{% endif %}
    """

{% for field in schema.fields %}
{% if field.is_required %}
{% if field.validators %}
    {{ field.field_name }}: {{ field.field_type }} = Field(
        ...,
{% for validator in field.validators %}
        {{ validator }},
{% endfor %}
        description="{{ field.description }}"
    )
{% else %}
    {{ field.field_name }}: {{ field.field_type }} = Field(
        ...,
        description="{{ field.description }}"
    )
{% endif %}
{% else %}
{% if field.default_value %}
    {{ field.field_name }}: {{ field.field_type }} = Field(
        default={{ field.default_value }},
        description="{{ field.description }}"
    )
{% else %}
    {{ field.field_name }}: {{ field.field_type }} = Field(
        default=None,
        description="{{ field.description }}"
    )
{% endif %}
{% endif %}
{% endfor %}

    @property
    def content(self) -> str:
        """Convert structured output to content string for backward compatibility.
        
        This property allows existing code that accesses .content to work
        seamlessly with structured output.
        """
        return self.to_content()
    
    def to_message(self):
        """Convert to LangChain AIMessage for message list compatibility.
        
        Returns:
            AIMessage with formatted content, or self if langchain not available.
        """
        if _HAS_LANGCHAIN:
            return AIMessage(content=self.to_content())
        return self
    
    def to_content(self) -> str:
        """Convert the structured output to a formatted string.
        
        Returns:
            A formatted string representation suitable for messages and logs.
        """
        # Smart formatting based on field types and names
        parts = []
        data = self.model_dump()
        
        # Look for common "main content" fields first
        primary_fields = ['summary', 'rationale', 'content', 'report', 'report_markdown', 
                         'thesis', 'bull_thesis', 'bear_thesis', 'analysis_summary']
        
        # Add primary content fields first (if they exist)
        for field_name in primary_fields:
            if field_name in data and data[field_name]:
                parts.append(str(data[field_name]))
        
        # Then add other important fields
        for field_name, field_value in data.items():
            if field_name in primary_fields or field_value is None:
                continue
                
            # Format based on type
            if isinstance(field_value, list) and field_value:
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:**")
                for item in field_value:
                    parts.append(f"- {item}")
            elif isinstance(field_value, float):
                # Format percentages nicely
                if 'confidence' in field_name or 'probability' in field_name:
                    parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value:.1%}")
                else:
                    parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value:.2f}")
            elif isinstance(field_value, bool):
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {'Yes' if field_value else 'No'}")
            elif isinstance(field_value, str) and field_value:
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value}")
            elif hasattr(field_value, 'value'):  # Enum
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value.value}")
        
        return "\n".join(parts) if parts else str(data)

{% endif %}
{% endfor %}
